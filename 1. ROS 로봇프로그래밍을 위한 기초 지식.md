# ROS 로봇프로그래밍을 위한 기초 지식
## 1. Pub/Sub 통신
### [Publish / Subscribe]
 Pub/Sub는 이벤트를 처리하는 서비스에서 이벤트를 생성하는 서비스를 분리하는 비동기 메시징 서비스이다. 메시징 기준 미들웨어 또는 스트리밍 분석 파이프라인의 이벤트 수집 및 전송으로 사용할 수 있다. Pub/Sub는 규모에 맞는 고가용성 및 일관된 성능으로 내구성 있는 메시지 스토리지 및 실시간 메시지 전송을 제공한다. 
 많은 Pub / Sub들은 Publisher – Message broker – Subscriber의 구조를 사용하고 있다. Pub / Sub 통신에서 메시지를 보내는 Publisher는 어떤 Subscriber가 있는지 모르는 상태에서 메시지를 publish 하게 되고 Master(Message Broker)에 의해 필터링 되어 필요로 하는 Subscriber에게 전달된다. publish 된 메시지는 여러 개의 클래스로 나누어지며 Subscriber는 publisher에 대한 지식 없이 자신이 필요로 하는 메시지만을 전송받는다. 이 말은 곧 여러 메시지 중에서 Subscriber에게 보내지는 메시지를 선택하고 그를 처리하는 작업이 존재한다는 얘기이다. 이러한 작업은 Message Filtering이라고 하고, 이 작업을 크게 두 가지 종류로 구분할 수 있고 그 두 가지 종류를 합친 한 가지 방법까지 총 세 가지 방법으로 구분할 수 있다.

### [Message Filtering]
1. Topic-based system : Publisher가 먼저 message의 클래스를 정의한 후 그 topic으로 메시지를 전송하면 Subscriber는 Subscribe 한 topic으로 전송되는 메시지만을 전송받을 수 있게 된다. 같은 topic에 subscribe 한 subscriber들은 똑같은 메시지를 받을 수 있다.
2. Content-based system : Publisher가 아닌 Subscriber가 메시지를 분류하게 된다. 즉 Subscriber가 메시지에 대해 자신이 원하는 조건을 정의해두면 그 조건에 맞는 메시지만이 Publisher로부터 전송이 되는 형태이다.
3. Hybrid system : 위 두 시스템의 형태를 합쳐놓은 형태로 Publisher가 메시지의 topic을 정의해놓고 각 topic으로 메시지를 Publish 하면, 전송된 메시지 중 그 topic에 Subscribe 한 Subscriber들이 정의해둔 content-based 조건에 맞는 메시지만이 Subscriber에게 전송되는 형태이다.

### [장점 / 단점]
• 장점
- 높은 확장성     
 : 상대적으로 적은 설치 규모보다 병행 작동, 메시지 캐싱, 트리 기반/네트워크 기반 라우팅 등을 통해 높은 확장성을 제공한다.

• 단점
- 확장성으로부터 발생하는 문제     
 : 높은 확장성에 의해 많은 문제가 발생할 수 있다.    
1) 시스템 규모가 확장되면서 Pub/Sub 통신은 많은 처리량에 대해 불안정성을 보이게 된다.    
2) 많은 애플리케이션이 Pub/Sub 통신을 사용함으로 인한 slowdown이 문제가 될 수 있다.    
3) 많은 트래픽이 몰리면서 local network를 셧다운 시켜버리는 IP-storm 문제가 생길 수 있다.    
- 보안 문제    
 : Message Broker를 사용하는 Pub/Sub 통신의 경우에는 메시지를 보낼 때 in-band 방식을 사용하는데, 이는 보안 문제를 발생시킬 수 있다.      
메인 데이터를 동반하는 제어 데이터를 누군가가 악의적으로 조작할 경우 Broker는 Subscription을 찾기 위해서 대역폭 등의 자원을 할당하게 되고, 결국 이는 DoS(Denial of Service)와 같은 영향을 주게 된다.
Broker를 사용하지 않을 때도 인증되지 않은 Publisher가 발행한 메시지를 Subscriber가 받을 수 있는 등의 문제가 발생 가능하다.


### [강의에서 설명하는 메시지 통신]
① Message Broker인 Master에 Subscriber 노드 정보를 보내고 Publisher 노드 정보도 보낸다.     
② Subscriber 노드에 새로운 Publisher 정보를 알려준다.     
③ Master로부터 받은 Publisher 정보를 이용하여 TCPROS 접속을 요청한다.    
④ 접속 응답에 해당하는 자신(Publisher)의 TCP URI 주소와 포트 번호를 전송한다.   
⑤ TCPROS를 이용하여 Publisher와 직접 연결한다. (Subscriber가)    
⑥ Publisher는 Subscriber에게 메시지를 전송한다. (Topic 전송)    
- Topic 방식에서는 접속을 끊지 않는 이상 지속해서 메시지를 전송한다. (연속성)

⑦ 1회에 한해 접속, 서비스 요청 및 서비스 응답이 수행되고 서로 간의 접속을 끊는다.      
- 서비스는 토픽과 달리 1회에 한해 접속하고 서비스 요청 및 서비스 응답이 수행되면 서로 간의 접속을 끊는다. (일회성)    

## 2. 리눅스 쉘
리눅스의 쉘은 명령어와 프로그램을 실행할 때 사용하는 인터페이스이다. 쉘은 커널과 사용자 간의 다리 역할을 하는 것으로 사용자로부터 명령을 받아 그것을 해석하고 프로그램을 실행한다. 쉘은 쉽게 말해 터미널처럼 명령어를 입력하는 환경을 말한다. 쉘은 Windows의 명령 프롬프트와 비슷해 보이지만 훨씬 강력한 프로그래밍 기능을 하고 있다.

### [쉘의 기능]
- 사용자와 커널 사이에서 명령을 해석해 전달하는 명령어 해석기 기능    
: 사용자와 커널 사이에서 명령을 해석하여 전달하는 명령어 해석기 기능을 한다.    
- 쉘은 자체 내에 프로그래밍 기능이 있어 프로그램 작성 가능    
: 쉘 프로그래밍 기능을 이용하면 여러 명령을 사용해 반복적으로 수행하는 작업을 하나의 프로그램으로 제작할 수 있다. 쉘 프로그램을 쉘 스크립트라고 부른다.    
- 사용자 환경 설정의 기능    
: 초기화 파일 기능을 이용해 사용자의 환경을 설정할 수 있다. 로그인할 때 이 초기화 파일이 실행되어 사용자의 초기 환경이 설정된다.     

### [쉘의 종류와 특징]
쉘은 커널에서 분리된 별도의 프로그램으로 다양한 종류의 쉘이 존재하고 현재까지도 지속해서 개발되고 있다.
#### * Bourne shell –sh
 : 최초의 본격적인 쉘로 유닉스 쉘의 오리지널이라고 할 수 있다. 오리지널인만큼 모든 유닉스 시스템에서 사용할 수 있으나 오리지널이라 미흡한 점이 많다. 그중 가장 큰 단점은 상호대화식 방식을 취하고 있지 않다. .sh라는 파일 확장자를 가진 파일이 특정 종류의 쉘 스크립트를 가리키는 것이 보통이지만 대부분의 쉘 스크립트는 파일 확장자를 지니지 않는다.

#### * C 쉘 – C shell, csh
 : C 쉘은 C언어를 기반으로 만들어졌다. C쉘은 강력한 프로그램 작성 기능이 있다. 쉘 스크립트 언어는 C와 비슷하다. 크기가 커지고 처리속도가 느려졌다는 단점이 있지만 편리한 기능 때문에 일반 사용자들이 즐겨 사용했던 쉘이다.

#### * 콘 쉘 – Korn shell, ksh
 : 콘 쉘 역시 오리지널인 sh(본 쉘)를 확장하여 만들었으며 C쉘의 많은 기능을 추가했다. C 쉘의 특징들을 모두 제공하면서 처리속도도 빠르다는 장점이 있다.

#### * bash
 : 현재 리눅스의 표준 쉘이다. bash는 korn shell과는 다르게 공짜였으므로 급속히 전파되었다. bash 쉘은 sh를 기반으로 Korn shell(ksh)과 C shell(csh)의 좋은 점만 합한 것이다. bash는 리눅스뿐만 아니라 GNU 운영체제, 맥 OS X등 다양한 운영체제에서 사용 중이다.
##### [bash의 특징]
- Alias 기능 (명령어 단축 기능)
- History 기능
- 연산 기능
- Job Control 기능
- 자동 이름 완성기능
- 프롬프트 제어 기능 등 다양한 기능이 있다.

### [쉘 확인 및 변경]
- 쉘 확인    
: ‘grep cent /etc/passwd’ 명령어를 입력하면 grep 명령어가 계정 정보가 저장된 파일(/etc/passwd)에서 문자열(cent)이 포함된 라인을 보여준다. 이때 나오는 /bin/ 뒤의 쉘 이름이 해당 계정의 기본 쉘이 된다.
- 쉘 변경    
: ‘chsh’ 명령어를 입력하면 쉘을 바꾸기 위해 입력을 받는다. ‘/bin/쉘_이름’을 입력하면 입력한 쉘로 쉘의 종류가 변경된다.

![image](https://user-images.githubusercontent.com/57993534/126039086-87988757-8428-4864-8a56-da01b4c6c272.png)

## 3. OSI 7계층
국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다. 일반적으로 OSI 7계층 모형이라고 하며, 개방형 시스템 상호 연결 모델의 표준이다. TCP/IP는 OSI 7계층을 기반으로 상업적·실무적으로 이용될 수 있도록 단순화한 것이다. 각 계층은 하위 계층의 기능만 이용하고, 상위 계층에게 기능을 제공한다. 이러한 계층들로 구성되는 프로토콜 시스템이 구현된 시스템을 ‘프로토콜 스택’ 또는 ‘스택’이라 하며, 프로토콜 스택은 하드웨어나 소프트웨어 혹은 둘의 혼합으로 구현될 수 있다. 일반적으로 하위 계층들은 하드웨어로, 상위 계층들은 소프트웨어로 구현된다.

### [작동 원리]
OSI 7계층은 응용 계층, 표현 계층, 세션 계층, 전송 계층, 네트워크 계층, 데이터 링크 계층, 물리 계층으로 나뉜다. 전송(송신) 시에 7계층에서 1계층 방향으로 각각의 층마다 인식 가능한 헤더를 붙이고(Encapsulation), 수신 시에는 1계층에서 7계층 방향으로 헤더를 떼어낸다(Decapsulation).
출발지에서 데이터가 전송될 때에는 헤더가 추가되는데, 2계층(데이터 링크 계층)에서만 오류 제어를 위해서 꼬리 부분에 추가된다. 물리 계층에서 데이터는 1, 0의 신호가 되어 전송 매체(동축 케이블, 광섬유 등)을 통해 전송된다.

### [계층별 특성]
컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것

![image](https://user-images.githubusercontent.com/57993534/126039098-4ad1b323-c45c-4992-9fb8-f03a59c07701.png)

 이 모델은 프로토콜을 기능별로 나눈 것이다. 각 계층은 하위 계층의 기능만을 이용하고 상위 계층에게 기능을 제공한다. ‘프로토콜 스택’ 혹은 ‘스택’은 이러한 계층들로 구성되는 프로토콜 시스템이 구현된 시스템을 가리키는데 프로토콜 스택은 하드웨어나 소프트웨어 혹은 둘의 혼합으로 구현될 수 있다. 일반적으로 하위 계층들은 하드웨어로, 상위 계층들은 소프트웨어로 구현된다.

- 계층 1 : 물리계층    
 물리계층은 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다. 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다. 다양한 특징의 하드웨어 기술이 접목되어 있기에 OSI 아키텍처에서 가장 복잡한 계층으로 간주한다.
 시스템의 전기적, 물리적 표현을 나타낸다. 인터넷 케이블, 라우터 스위치 등의 전기적 신호가 물리적인 장치에 의해 왔다 갔다 하는 곳을 말함.     
(ex. 케이블 종류, 무선 주파수 링크, 핀 배치, 전압, 물리 요건 등)

- 계층 2 : 데이터 링크 계층    
 데이터 링크 계층은 포인트 투 포인트 간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다. 네트워크 위의 개체 간 데이터를 전달하고, 물리계층에서 발생할 수 있는 오류를 찾아내고 수정하는 데 필요한 기능적, 절차적 수단을 제공한다. 주소값은 물리적으로 할당받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소가 정해져 있다는 뜻이다. 주소 체계는 계층이 없는 단일 구조이다. 
  + 주소할당 : 물리계층으로부터 받은 신호들이 네트워크상의 장치에 올바르게 안착할 수 있게 한다.
  + 오류감지 : 신호가 전달되는 동안 오류가 포함되는지 감지 오류가 있다면 해당 데이터를 폐기한다.    
(ex. 이더넷, 포인트 투 포인트 프로토콜, 패킷 스웨칭 네트워크, 근거리 네트워크용 프로토콜)

- 계층 3 : 네트워크 계층    
 네트워크 계층은 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고 그 과정에서 전송 계층이 요구하는 서비스 품질을 제공하기 위한 기능적, 절차적 수단을 제공한다. 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션, 오류 제어, 인터네트워킹 등을 수행한다. 대부분의 라우터가 이 계층에서 동작하고 이 계층에서 동작하는 스위치도 있다. 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다. 가장 기본적으로 볼 때 이 계층은 다른 여러 라우터를 통한 라우팅을 비롯한 패킷 전달을 담당한다. 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며 계층적이다. 
 서브 네트의 최상위 계층으로 경로를 설정하고 청구 정보를 관리한다. 개방형 시스템들 사이에서 네트워크 연결을 설정, 유지, 해제하는 기능을 부여하고 전송 계층 사이에 네트워크 서비스 데이터 유닛을 교환하는 기능을 제공한다.

- 계층 4 : 전송 계층    
 전송 계층은 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고받을 수 있도록 해주고 보낼 데이터의 용량과 속도, 목적지 등을 처리하여 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다. 시퀀스 넘버 기반의 오류 제어 방식을 사용한다. 전송 계층은 특정 연결의 유효성을 제어하고 일부 프로토콜은 상태 개념이 있고 연결 기반이다. 이는 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다. 종단 간 통신을 다루는 최하위 계층으로 종단 간 신뢰성 있고 효율적인 데이터를 전송하며 기능은 오류 검출 및 복구와 흐름 제어, 중복 검사 등을 수행한다.     
(ex. 전송제어 프로토콜(TCP) : TCP는 인터넷 프로토콜(IP) 위에서 구축된다. 흔히 말하는 TCP/IP의 IP가 주소가 여기서 작동한다.)

- 계층 5 : 세션 계층    
 세션 계층은 양 끝단의 응용 프로세스가 통신을 관리하는 방법을 제공한다. 동시 송수신 방식, 반이중방식(무전기), 전이중 방식(전화기)의 통신과 함께 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다. 통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 다룬다.
 이 프로토콜은 연결이 손실되는 경우 연결 복구를 시도하고 만약 오랜 시간 연결이 되지 않으면 세션 계층의 프로토콜이 연결을 닫고 다시 연결을 재개한다. 

- 계층 6 : 표현 계층    
 표현 계층은 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다. 응용 계층의 데이터 표현에서 독립적인 부분을 나타낸다. 일반적으로 응용프로그램 형식을 준비 또는 네트워크 형식으로 변환하거나 네트워크 형식을 응용프로그램 형식으로 변환하는 것을 나타낸다. 다시 말하면 이 계층은 응용프로그램이나 네트워크를 위해 데이터를 ‘표현’하는 것이다.
(ex. MIME 인코딩, 암호화, 복호화 등)

- 계층 7 : 응용 계층    
 응용 계층은 최상위 계층으로 사용자에게 보이는 부분으로 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다. OSI 모형에서 최종 사용자에게 가장 가까운 계층이며 사용자와 직접적으로 상호작용한다.
(ex. 웹 브라우저, 응용프로그램, 네트워크 소프트웨어 UI 부분, 사용자의 입출력 부분 등)

## 4. TCP/IP 소켓 통신
### [소켓의 정의]
소켓은 소프트웨어로 작성된 추상적인 개념의 통신 접속점이라고 할 수 있는데 네트워크 응용프로그램은 소켓을 통해 통신망으로 데이터를 송수신하게 된다. 소켓은 응용프로그램에서 TCP/IP를 이용하는 창구 기능을 하며 응용프로그램과 소켓 사이의 인터페이스 역할을 하고 있다. 
 두 프로그램이 네트워크를 통해 서로 통신을 수행할 수 있도록 각각 양쪽에 생성되는 링크의 단자가 소켓이다. 두 소켓이 연결되면 서로 다른 프로세스끼리 데이터를 전달할 수 있다. 결국, 소켓이 구현됨으로써 네트워크 및 전송계층의 캡슐화가 가능해진다. 소켓은 통신을 위한 일종의 통로라고 생각할 수 있다. 기본적으로 소켓은 상대방에게 데이터를 보내거나 받는 역할을 한다.
- 서버 소켓(Server Socket)   
: 서버 프로그램에서만 사용하는 소켓으로, 클라이언트로부터 연결 요청이 오기를 기다렸다가 요청이 들어오면 클라이언트와 연결을 맺고 다른 소켓을 만드는 일을 한다.
- 클라이언트 소켓(Client Socket)    
: 요청을 기다릴 필요가 없기 때문에 바로 클라이언트 소켓을 생성한다. 클라이언트 프로그램에서 클라이언트 소켓은 서버 프로그램으로 연결 요청을 하는 것과 데이터 전송을 하는 일을 한다.
- Stream 방식 소켓    
: 양방향 연결을 필요로 하며, 송신지에서 수신지까지 데이터가 손실되거나 변하지 않도록 보장해주고 보낸 순서대로 받을 수 있게 해준다. 그러나 보낸 한 개의 패킷을 여러 개로 나누어 받거나 반대로 여러 개의 패킷을 한 개로 뭉쳐서 받을 수 있으므로 그에 대한 적절한 처리를 따로 해주어야 한다.

### [Port의 정의]
 IP로 해당 PC에 접근은 했지만, PC 내부에서 어느 프로그램과 통신을 해야 하는지 구분을 해야 한다. 이때 사용하는 것이 포트이다. 즉 쉽게 말해 포트란 통신을 하기 위한 출입구이다. 각 프로그램은 자신만의 포트를 부여함으로 각각 통신할 때 구분을 할 수 있다.
 TCP(Transmission Control Protocol)은 보내는 쪽과 받는 쪽 간의 연결성을 제공하여 신뢰할 수 있는 패킷 전송 서비스를 제공한다. 여러 개의 패킷을 보낼 때 순서를 보장하며 패킷이 손실되거나 유실되면 그 부분을 재전송해주기도 한다. TCP/IP에서 TCP가 바로 이 프로토콜을 가리키는 것이며 TCP는 IP가 제공하지 않는 연결성, 신뢰성을 제공한다.
 TCP/IP 소켓 통신은 Stream 방식이다. 이 방식의 가장 큰 특징은 양방향 연결이 필요하다는 것이다. 보낸 곳에서 받는 곳까지 데이터가 소실되거나 변하지 않게 보장해주며 보낸 순서대로 수신할 수 있게 해준다. 하지만 보낸 한 개의 패킷을 여러 개로 나누어 받거나 반대로 여러 개의 패킷을 한 개로 뭉쳐서 받을 수 있으니 그에 대한 적절한 처리가 필요하다.

### [소켓 통신 방식]
: 소켓 통신은 다음과 같은 방식으로 이루어진다. 여기서 발신자는 클라이언트 소켓, 수신자는 서버 소켓으로 볼 수 있다. 클라이언트 소켓은 처음 소켓을 생성(socket())한 다음, 서버 측에 연결을 요청(connect())한다. 그리고 서버 소켓에서 연결이 받아들여지면 데이터를 송·수신(send()/recv())하고, 모든 처리가 완료되면 소켓을 닫는다(close()).
서버 소켓은 클라이언트 소켓보다 조금 복잡한 처리 과정을 가지고 있다. 일단 클라이언트 소켓과 마찬가지로, 소켓을 생성(socket())한다. 그다음, 서버가 사용할 IP주소와 포트 번호를 생성한 소켓에 결합(bind())한다. 그런 다음에 클라이언트로부터 연결 요청이 수신되는지 주시(listen())하고, 요청이 수신되면 요청을 받아들여(accept()) 데이터 통신을 위한 소켓을 생성한다. 일단 새로운 소켓을 통해 연결이 수립되면, 클라이언트와 마찬가지로 데이터를 송·수신(send()/recv())할 수 있게 된다. 마지막으로 데이터의 송·수신이 완료되면 소켓을 닫는다(close()).

- 클라이언트 소켓 프로그래밍
  + 클라이언트 소켓 생성(socket())   
: 소켓 통신을 위한 첫 단계이다. 이때 소켓의 종류를 지정 가능한데, TCP 소켓을 위해서는 Stream 타입으로 지정하면 된다. 최초 소켓이 만들어지는 시점에는 어떠한 연결 대상에 대한 정보도 들어있지 않고, 껍데기뿐인 소켓이 만들어진다. 연결 대상을 지정하고 연결 요청을 전달하기 위해서는 생성한 소켓을 사용해 connect() API를 호출해야 한다.
  + 연결 요청(connect())   
: connect() API는 IP주소와 포트 번호로 식별되는 대상(Target)으로 연결 요청을 보낸다. 이 API는 블록 방식으로 동작하므로 연결 요청에 관한 결과가 결정되기 전에는 connect()의 실행이 끝나지 않는다. connet() API 호출이 성공하면 send()/recv() API를 통해 데이터를 주고받을 수 있다.
  + 데이터 송·수신(send()/recv())   
: 연결된 소켓을 통해서 데이터를 보낼 때는 send(), 데이터를 받을 때는 recv API를 사용한다. 이 두 API 또한 블록 방식으로 동작하므로 실행 결과가 결정되기 전까지는 API가 리턴되지 않는다. 특히 recv()는 데이터가 수신되거나 에러가 발생하기 전에는 실행이 종료되지 않기 때문에 데이터 수신 작업은 처리하기 쉽지 않다. 
send()의 경우에는 데이터를 보내는 주체가 자기 자신이기 때문에 데이터를 얼마나, 언제 보낼 것인지 알 수 있다. 그러나 데이터를 수신하는 경우에는 통신 대상이 언제, 어떤 데이터를 보낼지 특정할 수 없으므로 recv() API가 한 번 실행되면 언제 끝날지 모르는 상태가 된다. 따라서 recv() API는 별도의 스레드에서 실행한다.
send()/recv() API를 통해 데이터 송·수신이 완료되면 close() API로 소켓을 닫는다.
  + 소켓 닫기(close())   
: 더 이상 데이터 송·수신이 필요 없게 되면, 소켓을 닫기 위해 close() API를 호출한다. 닫힌 소켓은 더 이상 유효한 소켓이 아니므로, 해당 소켓으로 데이터를 송·수신할 수 없다. 소켓 연결 종료 후에도 또다시 데이터를 주고받고자 한다면, 또 한 번의 소켓 생성(socket())과 연결(connect()) 과정을 통해 소켓이 데이터를 송·수신할 수 있는 상태가 되어야 한다.

- 서버 소켓 프로그래밍
  + 서버 소켓 생성(socket())    
: 클라이언트 소켓과 마찬가지로, 서버 소켓을 사용하기 위해서는 최초에 소켓을 생성해야 한다.
  + 서버 소켓 바인딩(bind())    
: 서버 소켓은 일반적으로 고정된 포트 번호를 사용하며 그 포트 번호로 클라이언트의 연결 요청을 받아들이므로, 운영체제가 특정한 포트 번호를 서버 소켓이 사용하게 하려고 bind() API는 소켓과 포트 번호를 결합하는 역할을 해 준다. bind() API에 사용되는 인자는 소켓과 포트 번호(또는 IP주소 + 포트 번호)이다. 운영체제에서는 소켓들이 중복된 번호를 사용하지 않도록 내부적으로 포트 번호와 소켓 연결 정보를 관리하는데, bind() API는 해당 소켓이 지정된 포트 번호를 사용할 것이라고 운영체제에 요청한다. 만약 지정된 포트 번호를 다른 소켓이 사용하고 있다면, bind() API는 에러를 리턴한다. bind() API를 호출하는 것을 소켓 바인딩이라고 한다.
  + 클라이언트 연결 요청 대기(listen())    
: 서버 소켓에 포트 번호(또는 IP주소+포트 번호)를 결합하고 나면, 서버 소켓을 통해 클라이언트의 연결 요청을 받아들일 준비가 된 것이다. listen() API는 클라이언트에 의한 연결 요청이 수신될 때까지 기다리는 역할을 한다. listen() API는 서버 소켓에 바인딩 된 포트 번호로 클라이언트의 연결 요청이 있는지 확인하며 대기 상태에 머무른다. 클라이언트에서 호출된 connect() API에 의해 연결 요청이 수신되는지 지켜보고 있다가, 요청이 수신되면 대기 상태를 종료하고 리턴한다.
listen() API가 대기 상태에서 빠져나오는 경우는 클라이언트 요청이 수신되는 경우와 에러가 발생(close() 포함)하는 경우이다. listen() API의 리턴 값은 클라이언트 연결 요청이 수신되었는지(SUCCESS), 그렇지 않고 에러가 발생했는지(FAIL)의 두 가지이다. 연결 요청에 대한 정보는 시스템 내부적으로 관리되는 큐에 쌓이게 되고, 이 시점에서 클라이언트와의 연결은 아직 완전히 연결되지 않은 상태이다. 대기 중인 연결 요청을 큐에서 꺼내와서 연결을 완료하기 위해서는 accept() API를 호출해야 한다.
  + 클라이언트 연결 수립(accept())    
: accept() API는 최종적으로 연결 요청을 받아들이는 역할을 한다. 이 API는 연결 요청을 받아들여 소켓 간 연결을 수립하지만, 최종적으로 데이터 통신을 위해 연결되는 소켓은 bind() 또는 listen() API에서 사용한 서버 소켓이 아닌 accept API 내부에서 새로 만들어지는 소켓이다.
  + 데이터 송·수신(send()/recv())    
: 데이터를 송·수신하는 과정은 클라이언트 소켓프로그래밍과 같다.
  + 소켓 연결 종료(close())    
: 클라이언트 소켓프로그래밍과 마찬가지로 소켓을 닫기 위해서는 close() API를 호출하면 되는데, 서버 소켓에서는 close()의 대상이 최초 socket() API를 통해 생성한 서버 소켓과 accept() API 호출로 생성된 소켓도 관리해야 한다.

![image](https://user-images.githubusercontent.com/57993534/126039194-4021bbfb-a0be-4d29-a237-4c6581a171f8.png)

소켓 통신 과정의 순서도         -            순서도를 코드로 변환한 것

## 5. Middleware 미들웨어
 컴퓨터 제작 회사가 사용자의 요구대로 만들어 제공하는 프로그램으로, 운영체제와 응용 소프트웨어의 중간에서 조정과 중개의 역할을 수행하는 소프트웨어이다. 양쪽(운영체제와 응용 소프트웨어)을 연결하여 데이터를 주고받을 수 있도록 중간에서 매개 역할을 하며, 네트워크를 통해서 연결된 여러 개의 컴퓨터에 있는 많은 프로세스들에 어떤 서비스를 사용할 수 있도록 연결해준다. 

### [장점]
- 표준화된 인터페이스를 제공할 수 있다.
- 다양한 환경을 지원하며, 체계가 다른 업무와 상호 연동이 가능하다.
- 분산된 업무를 동시에 처리 가능하여 자료의 일관성이 유지된다.
- 부하의 분산이 가능하다.

### [종류]
- 데이터베이스 미들웨어    
: 데이터베이스 공급업체에서 제공하는 소프트웨어로, 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어이다. 광범위한 의미에서 미들웨어라고 하지만, 실제로는 단순히 원격의 데이터베이스에 접근할 수 있도록 중개해주는 제품이라고 할 수 있다. 이 제품을 사용하여 시스템을 구축하는 경우를 보통 2-tier 아키텍처라고 한다.

ex) 오라클의 SQL*Net, IBM 인포믹스의 I*Net, ODBC 드라이버 등
- RPC(Remote Procedure Call) 미들웨어    
: 원격 procedure를 마치 로컬 procedure처럼 호출하는 방식의 미들웨어이다. 가트너 자료에 의하면 시장에서 점유율이 거의 없는 미들웨어이다. 엔테라의 제품은 외국에서는 판매 중단(End-Of-Life, EOL)되었고, 국내 공급회사에서 소스 판권을 사 새로운 운영체제에 포팅만 하는 상태로 기능 보강은 거의 되고 있지 않다고 한다.

ex) DCE RPC, 엔테라(RPC 기반에서 발전된 형태) 등
- MOM(Message Oriented Middleware) 미들웨어    
: 주로 비동기형 메시지 처리를 전달하는 방식의 미들웨어이다. 온라인 업무에 사용되기보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용되고 있다. IBM MQ 제품이 시장 점유율이 가장 높고, 향후 시장에서는 J2EE의 JMS 기반의 제품들과 경쟁 관계가 될 것으로 전망하고 있다고 한다.

ex) IBM MQ시리즈, BEA Message Q, J2EE의 JMS 기반 제품 등
- TP-모니터 미들웨어    
: 가장 대표적인 미들웨어로, 온-라인 트랜잭션 업무(은행 계정, 항공기/버스 예약 업무 등)에서 트랜잭션을 처리, 감시하는 미들웨어이다. 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 OLTP성의 업무에 적합하다. 현재 BEA Tuxedo가 세계 시장 점유율이 가장 높고, 향후에는 TP 기능이 있는 J2EE 기반의 WAS 제품들과 경쟁 관계가 예상된다고 한다.

ex) BEA TUXEDO, BEA TOPEND, IBM TxSeries, 대만 CS Talk 등
- ORB(Object Request Broker) 미들웨어    
: 객체지향 미들웨어로, 코바(CORBA) 표준 스펙을 구현한 미들웨어이다. 최근에는 TP-모니터의 장점(트랜잭션 처리, 모니터링 등)을 추가로 구현하고 있다고 한다. 현재 IONA Orbix 제품의 시장 점유율이 가장 높다. 객체지향 미들웨어로서 J2EE 기반의 WAS 제품에 경쟁에서 밀리고 있고, WAS 미들웨어에서 CORBA를 지원함으로써 점유율이 낮아지고 있는 상태라고 한다.

ex) IONA Orbix, Borland VisiBroker, BEA TUXEDO 8.0 이상 CORBA 엔진 등
- WAS(Web Application Server) 미들웨어    
: 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어이다. WAS는 HTTP 세션 처리를 위한 웹서버 기능뿐만 아니라 TP 기능을 보강하여 미션-크리티컬한 기업 업무까지 Java, EJB 컴포넌트 기반으로 구현할 수 있게 해주는 미들웨어이다.

ex) BEA WebLogic, IBM WebSphere, Oracle 9iAS, SUN iPlanet 등
